#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
//dor

#define ll long long
#define MAX_LENGTH 510
#define MAX_N 1000000007

//מערך שבו נשמור את כל התוצאות שחישבנו עד כה 
ll dp[MAX_LENGTH][MAX_LENGTH/2][MAX_LENGTH/2] = {0};

ll NPalindromes(const string &str, int N) {
    int length = str.length(); // אורך המילה שבודקים
    int num_group = (length + 1) / 2; // כמות זוגות האותיות 
    int num_mismatch = 0; //כמות הטעויות
    //לולאה שעוברת על ל המילה ובודקת אם היא פלינדרום
    for(int i=0; i<num_group; i++) {
        if(str[i] != str[length-i-1]) {
            num_mismatch++; //סוכמת את כל הזוגות שמונעות ממנה להיות פלינדרום
        }
    }
    dp[0][0][0] = 1; //מאתחלת את הטעות הראשונה ב1 
    
    // משנים n אותיות 
    for(int n=0; n<=N; n++) {
        //רצים על חצי מחרוזת כי מסתכלים על זוגות של אחד מכל צד 
        for(int k=1; k<=num_group; k++) {
            // לכל זוג בודקים  מה הוא ובהתאמם אליו לכמות
            //  השינוים שניתן לעשות סוכמים בתא המאים אליו במערך את השינוי האפשרים
            for(int b=0; b<=num_mismatch; b++) {
               // בודק אם אנחנו באמצע כשהמחרוזת אי זוגית 
               if(k-1 == length-k) {          
                    //שומר על הסכות השינויים שמצאנו עד עכשיו
                    dp[n][k][b] = dp[n][k-1][b];
                    // אם יש לנו אפשרות לשנות לפחות עוד אות אחת                  
                    if(n>=1) }
                        {                       
                    // מוסיף לסכום הזה גם את כל השישוניים עשישנו עד עכשיו כפול 25
                    // אותיות שונות שאפשר לשים באמצ כי כן אפשר לנצל את השינוי
                            dp[n][k][b] = (dp[n][k][b] + 25 * dp[n-1][k-1][b]) % MAX_N;
                        }
                    
                }
                //אם אנחנו לא באמצע והאותיות שוות בזוג בו אנחנו נמצאים
                else if(str[k-1] == str[length-k]) {
                //מוסיף לזוג הנוכחי את כל מה שמצא עד כה
                    dp[n][k][b] = dp[n][k-1][b];
                    // אם יש לנו יותר משתי אפשרויות החלפה
                    if(n>=2) 
                      {
                    // מוסיף לסכום הזה גם את כל השישוניים שעשינ
                    // ו לפני שתי אותיותת בזוג הזה בכמות הטעויות הנוכחית
                   // כי צריך לחליף 2 אותיות ולא אות אחת  
                        dp[n][k][b] = (dp[n][k][b] + 25 * dp[n-2][k-1][b]) % MAX_N;
                      }
                }
                //אם זוג האותיות ה
                // K
                // לא שווה
                else if(str[k-1] != str[length-k]) {
                // אם ניתן לשנות לפחות אות אחת  ונותר לנו טעות אחת לפחות 
                    if(b>=1 && n>=1) {
                        dp[n][k][b] = 2 * dp[n-1][k-1][b-1];
                    }
                    //אם יש אפשרות להחליף יותר מאות אחת
                    if(n>=2){
                          dp[n][k][b] = (dp[n][k][b] + 24 * dp[n-2][k-1][b-1]) % MAX_N;
                    }
                }
            }
        }
    }
 //   מחזיר את כמות החילופים האפשרים
    return dp[N][num_group][num_mismatch];
}


int main() {
    int T; // כמות בדיקות 
    cin >> T; //קליטת כמות בדיקות
    string str; // מילה שאותה בודקים 
    int n;
    
    //קליטה של כל אחד מהבדיקות 
    for(int t=0; t<T; t++) {
        cin >> n >> str; // קליטת המספר ה N  ו קליטת המילה 
        cout << NPalindromes(str, n) << endl; // שליחה לפונקציה שבודת ודפסת התוצאה 
    }
    
    return 0;
}
